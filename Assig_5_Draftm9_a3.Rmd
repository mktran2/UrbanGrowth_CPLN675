---
title: "Austin Growth Model"
author: "Adil Belgaumi and Mimi Tran"
date: "2024-05-01"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    code_folding: hide
    code_download: true
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
options(scipen = 999)
```

```{=html}
<style>
  .superbigimage{
      overflow-x:scroll;
      white-space: nowrap;
  }

  .superbigimage img{
     max-width: none;
  }


</style>
```
# 1. Introduction

For over a decade, the Austin-Round Rock-San Marcos Metropolitan
Statistical Area (MSA) has been the fastest growing metro area in the
nation. As climate change threatens Greater Austin and the rest of
Central Texas with longer, hotter, and drier summers, it is imperative
that Austin regional planners prioritize the region's natural resources
while ensuring that development occurs safely. We created a model to do
just that.

To create the model, we assumed development is attracted to existing
development and accessibility. Based on this assumption and identifying
sensitive environmental areas like wetlands and forests, we mapped where
development should be allocated.

We modeled two scenarios of how development may occur in 2031: 1)
business-as-usual (BAU) 2) Project Connect. Using historical development
patterns from Scenario 1, we created a model to forecast where
development may occur by 2031. The following sections outline how we
created our model through Scenario 1 and how we utilized the model in
Scenario 2.

Ultimately, we found that **Williamson County** will experience the
highest mean development demand by 2031 as well as a considerable
population increase. Planning efforts should prioritize new development
in Williamson County. We recommend that planning for new development in
Williamson County should prioritize where residents will most need and
use development, while taking care to protect the county's wetlands and
forests (see our Development Allocation Map)

```{r load_packages, message=FALSE, warning=FALSE, results = "hide"}
if(!require(pacman)){install.packages("pacman"); library(pacman)}
p_load(tidyverse, sf, raster, knitr, kableExtra, tidycensus, tigris, FNN, caret,
       yardstick, pscl, plotROC, ggrepel, pROC, grid, gridExtra, viridis, igraph,
       tmap,rasterVis, here)

plotTheme <- theme(
  plot.title =element_text(size=12),
  plot.subtitle = element_text(size=8),
  plot.caption = element_text(size = 6),
  axis.text.x = element_text(size = 10, angle = 45, hjust = 1),
  axis.text.y = element_text(size = 10),
  axis.title.y = element_text(size = 10),
  # Set the entire chart region to blank
  panel.background=element_blank(),
  plot.background=element_blank(),
  #panel.border=element_rect(colour="#F0F0F0"),
  # Format the grid
  panel.grid.major=element_line(colour="#D0D0D0",size=.75),
  axis.ticks=element_blank())

mapTheme <- theme(plot.title =element_text(size=12),
                  plot.subtitle = element_text(size=8),
                  plot.caption = element_text(size = 6),
                  axis.line=element_blank(),
                  axis.text.x=element_blank(),
                  axis.text.y=element_blank(),
                  axis.ticks=element_blank(),
                  axis.title.x=element_blank(),
                  axis.title.y=element_blank(),
                  panel.background=element_blank(),
                  panel.border=element_blank(),
                  panel.grid.major=element_line(colour = 'transparent'),
                  panel.grid.minor=element_blank(),
                  legend.direction = "vertical", 
                  legend.position = "right",
                  plot.margin = margin(1, 1, 1, 1, 'cm'),
                  legend.key.height = unit(1, "cm"), legend.key.width = unit(0.2, "cm"))

palette2 <- c("#41b6c4","#253494")
palette4 <- c("#a1dab4","#41b6c4","#2c7fb8","#253494")
palette5 <- c("#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494")
palette10 <- c("#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4",
               "#4eb3d3","#2b8cbe","#0868ac","#084081","#f7fcf0")

quintileBreaks <- function(df,variable) {
    as.character(quantile(df[[variable]],
                          c(.01,.2,.4,.6,.8),na.rm=T))
}

#This function can be used to convert a polygon sf to centroids xy coords.
xyC <- function(aPolygonSF) {
  as.data.frame(
    cbind(x=st_coordinates(st_centroid(aPolygonSF))[,1],
          y=st_coordinates(st_centroid(aPolygonSF))[,2]))
} 

#this function convert a raster to a data frame so it can be plotted in ggplot
rast <- function(inRaster) {
  data.frame(
    xyFromCell(inRaster, 1:ncell(inRaster)), 
    value = getValues(inRaster)) }

legend_format <- function(value)
  {round(value, digits = 2)}

legend_format3 <- function(value)
  {round(value, digits = 3)}

legend_formatper <- function(value)
{paste0(round(value*100, digits = 1),"%",sep= "")}

aggregateRaster <- function(inputRasterList, theFishnet) {
  #create an empty fishnet with the same dimensions as the input fishnet
  theseFishnets <- theFishnet %>% dplyr::select()
  #for each raster in the raster list
  for (i in inputRasterList) {
  #create a variable name corresponding to the ith raster
  varName <- names(i)
  #convert raster to points as an sf
    thesePoints <-
      rasterToPoints(i) %>%
      as.data.frame() %>%
      st_as_sf(coords = c("x", "y"), crs = st_crs(theFishnet)) %>%
      filter(.[[1]] > 0)
  #aggregate to the fishnet
    thisFishnet <-
      aggregate(thesePoints, theFishnet, mean) %>%
      mutate(!!varName := ifelse(is.na(.[[1]]),0,.[[1]]))
 #add to the larger fishnet
    theseFishnets <- cbind(theseFishnets,thisFishnet)
  }
  #output all aggregates as one large fishnet
   return(theseFishnets)
}

devM <- 
  matrix(c(
    0,12,0,
    12,24,1,
    24,Inf,0),
  ncol=3, byrow=T)

forestM <- 
  matrix(c(
    0,40,0,
    40,45,1,
    45,Inf,0),
    ncol=3, byrow=T
  )

farmM <- 
  matrix(c(
    0,80,0,
    80,90,1,
    90,Inf,0),
    ncol=3, byrow=T
  )

wetlandM <- 
  matrix(c(
    0,89,0,
    89,100,1,
    100,Inf,0),
    ncol=3, byrow=T
  )


oUndevM <- 
  matrix(c(
    0,30,0,
    30,35,1,
    35,50,0,
    50,55,1,
    55,70,0,
    70,75,1,
    75,Inf,0),
    ncol=3, byrow=T
  )

waterM <- 
  matrix(c(
    0,15,1,
    15,Inf,0),
    ncol=3, byrow=T
  )

ClassMatrices <- list(devM,forestM,farmM,wetlandM,oUndevM,waterM)
ClassNames <- list("dev","forest","farm","wetland","oUndev","water")
```

# 2. Data Wrangling and Feature Engineering

```{r , echo=FALSE, message=FALSE, warning=FALSE, results='hide', fig.height= 4}
studyAreaCounties <-  get_acs(
    geography = "county", 
    variables = "B01001_001", 
    state = 48,  
    geometry = TRUE, 
    county=c("Hays", "Travis", "Williamson","Bastrop","Caldwell"),
    year = 2021) %>% 
  st_transform(crs = 6578) %>% 
  mutate(NAME = word(NAME,1, sep = " ")) %>% 
  dplyr::select(NAME)

```

```{r , echo=FALSE, message=FALSE, warning=FALSE, results='markup', fig.height= 4}
tm_shape(studyAreaCounties) +
  tm_polygons(col = palette5[1], border.col = "black") +
  tm_text(text = "NAME")
```

The business-as-usual (BAU) scenario serves as the basis for our model.
Using development and land cover data from 2011 and 2021, we created a
model that predicts where development demand may occur in 2031. The
following code create functions and the fishnet needed to build our
model.

The BAU scenario operates on the assumption that development is
attracted to existing development (Steif, 2019). In other words, where
development is already present, more development will follow.
Additionally, the BAU scenario assumes that development demand is
predicated on accessibility---the more accessible an area is, whether
that be due to transit networks, its proximity to other development, or
population density, the higher the demand for more development (Steif,
2019).

Based on these assumptions alongside features of the natural
environment, we came up with multiple factors that would most likely
affect development demand: a) distance to highways, b) distance to
existing development, c) population change, d) percentage wetland land
cover, e) percentage forest land cover, f) percentage farm cover, and g)
percentage other undeveloped land cover(see Figure 3).

## 2.1. Population Data From Census Bureau

Population estimates were gotten from the American Community Surveys for
2011 and 2021.

```{r load ACS Data, message=FALSE, warning=FALSE, results='hide'}
acs_variables <- load_variables(2021, "acs5")

MSAShape <- get_acs(
    geography = "county", 
    variables = "B01001_001",
    state = 48,  
    geometry = TRUE, 
    county=c("Hays", "Travis", "Williamson","Bastrop","Caldwell"), 
    year = 2021) %>% 
  st_transform(crs = 6578) %>% 
  st_union()

studyAreaCounties <-  get_acs(
    geography = "county", 
    variables = "B01001_001", 
    state = 48,  
    geometry = TRUE, 
    county=c("Hays", "Travis", "Williamson","Bastrop","Caldwell"),
    year = 2021) %>% 
  st_transform(crs = 6578) %>% 
  mutate(NAME = word(NAME,1, sep = " ")) %>% 
  dplyr::select(NAME)

pop_2021 <- get_acs(
  geography = "tract", variables = "B01001_001", state = 48,  geometry = TRUE, 
                county=c("Hays", "Travis", "Williamson","Bastrop","Caldwell"), year = 2021) %>% 
  st_transform(crs = 6578) %>%
  rename(pop_2021 = estimate) %>% 
  st_buffer(-1)

pop_2011 <- get_acs(
  geography = "tract", variables = "B01001_001", state = 48,  geometry = TRUE, 
                county=c("Hays", "Travis", "Williamson","Bastrop","Caldwell"), year = 2011) %>% 
  st_transform(crs = 6578) %>%
  rename(pop_2011 = estimate) %>% 
  st_buffer(-1)

Austin_fishnet <- 
  st_make_grid(MSAShape, 2000) %>%
  st_sf() %>% 
  .[pop_2021, , op=st_intersects]

pop_fishnet <-
  Austin_fishnet %>%
  rownames_to_column("fishnetID") %>% 
  mutate(fishnetID = as.numeric(fishnetID)) %>%
  dplyr::select(fishnetID)

fishnetPop11 <-
  st_interpolate_aw(pop_2011["pop_2011"], pop_fishnet, extensive=TRUE) %>%
  as.data.frame(.) %>%
  rownames_to_column(var = "fishnetID") %>%
  left_join(pop_fishnet %>%
              mutate(fishnetID = as.character(fishnetID)),
            ., by=c("fishnetID"='fishnetID')) %>% 
  mutate(pop_2011 = replace_na(pop_2011,0)) %>%
  dplyr::select(pop_2011)

fishnetPop21 <-
  st_interpolate_aw(pop_2021["pop_2021"], pop_fishnet, extensive=TRUE) %>%
  as.data.frame(.) %>%
  rownames_to_column(var = "fishnetID") %>%
  left_join(pop_fishnet %>%
              mutate(fishnetID = as.character(fishnetID)),
            ., by=c("fishnetID"='fishnetID')) %>% 
  mutate(pop_2010 = replace_na(pop_2021,0)) %>%
  dplyr::select(pop_2021)

pop_fishnet <- 
  cbind(fishnetPop11,fishnetPop21) %>%
  dplyr::select(pop_2011,pop_2021) %>%
  mutate(pop_Change = pop_2021 - pop_2011)

tmap_arrange(
   tm_shape(pop_fishnet) +
     tm_fill(col = "pop_2011", palette = palette5, n = 5, style = "quantile",
             title = "Population of Cell,\n2011") +
     tm_layout(frame = F,legend.position = c("right", "bottom")),
   tm_shape(pop_fishnet) +
     tm_fill(col = "pop_2021", palette = palette5, n = 5, style = "quantile",
             title = "Population of Cell,\n2021") +
     tm_layout(frame = F,legend.position = c("right", "bottom")),
   tm_shape(pop_fishnet) +
     tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
             title = "Population Change\nof Cell,\n2011 - 2021") +
     tm_layout(frame = F,legend.position = c("right", "bottom")),
   ncol = 3)
```

## 2.2. Landcover Data

Land cover data was procured from the Multi-Resolution Land
Characteristics (MRLC) Consortium. It was then cropped to the Austin
area and reprojected in ArcGIS Pro.

```{r Load landcover data}
if(Sys.getenv("USERNAME") == "adgob") {
  lc_austin_11 <- raster(here::here("Data/lc_final/lc_austin_11.tif"))
  lc_austin_21 <- raster(here::here("Data/lc_final/lc_austin_21.tif"))
}  else {
    #put your directory paths here !
   lc_austin_11 <- raster("~/Desktop/modeling/HW5/austin 2011/lc_austin_11.tif")
   lc_austin_21 <- raster("~/Desktop/modeling/HW5/austin 2021/lc_austin_21.tif")
}
```

It was then reclassed to isolate each land cover type and aggregated to
the fishnet by means to give the percentage land cover of each type in
each cell.

```{r Creating the land cover classified rasters}
Raster_list2011 <- c()
Raster_names <- c()
for (x in 1:length(ClassMatrices)){ 
  # Reclassify land cover to the desired land cover type
  data <- reclassify(lc_austin_11, ClassMatrices[[x]])
  # Aggregate to get fraction of cell with that land type
  data <- aggregate(data, fact = 20, FUN = mean)
  # Name the data in the raster x_2011
  names(data) <- ClassNames[[x]]
  # Adds the raster to the raster list with the name x_2011_4000
  Raster_list2011 <- c(Raster_list2011,
                assign(ClassNames[[x]],data))
  # Adds the raster layer names to a list for running future code
  Raster_names <-  c(Raster_names,
                     ClassNames[[x]])
}

dev_2021 <- reclassify(lc_austin_21, devM)
dev_2021_4000 <- aggregate(dev_2021, fact = 20, FUN = mean)
names(dev_2021_4000) <- "dev_2021"
Raster_list2011 <- c(Raster_list2011, 
                     dev_2021_4000)
Raster_names <-  c(Raster_names,
                     "dev_2021")

development_change <- dev_2021_4000 - Raster_list2011[[1]] 
names(development_change) <- "dev_change"
Raster_list2011 <- c(Raster_list2011, 
                     development_change)
Raster_names <-  c(Raster_names,
                     "dev_change")
```

#### Fig 2.2.1. Land Cover Characteristic Maps, 2011

```{r Mapping Variables, fig.height= 15, fig.width= 11}
aggregatedRasters <-
  aggregateRaster(Raster_list2011, Austin_fishnet)%>%
  dplyr::select(all_of(Raster_names))

aggregatedRasters <- aggregatedRasters %>% 
  mutate(developed2011 = ifelse(dev > 0.3,1,0),  
         developed2021 = ifelse(dev_2021 > 0.3,1,0),
         development_change2 = developed2021 - developed2011
         ,development_change2 = ifelse(development_change2 < 1,
                                      0,
                                      1),
         maj_water = water > 0.5 # was 0.5 
         )

tmap_arrange(
  tm_shape(aggregatedRasters) +
  tm_fill(col = "dev", palette = palette5, n = 5, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Developed Land Cover 2011"),
  tm_shape(aggregatedRasters) +
    tm_fill(col = "forest", palette = palette5, n = 5, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Forest Land Cover 2011"),
  tm_shape(aggregatedRasters) +
    tm_fill(col = "farm", palette = palette4, n = 4, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Farm Land Cover 2011"), 
  tm_shape(aggregatedRasters) +
    tm_fill(col = "wetland", palette = palette4, n = 3, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Wetland Land Cover 2011"),
  tm_shape(aggregatedRasters) +
    tm_fill(col = "oUndev", palette = palette5, n = 5, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Other Undeveloped Land Cover 2011"), 
  tm_shape(aggregatedRasters) +
    tm_fill(col = "dev_change", palette = palette4, n = 3, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Land Cover Developed 2011 - 2021"), 
  tm_shape(aggregatedRasters) +
    tm_fill(col = "water", palette = palette4, n = 3, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Percent Water Land Cover 2011"),
  tm_shape(aggregatedRasters) +
    tm_fill(col = "maj_water", palette = palette2, n = 2, style = "cat") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              main.title = "Cell is Majority Water Feature 2011"), 
  ncol = 2)
```

Using a cutoff of 30% land cover to consider a plot developed,
development in 2011 and 2021 can be tracked and compared as a boolean
value. Below is a table showing whether a cell was developed in 2011 or
2021 depending on whether the cell's land cover is more than 50% water.
#### Fig 2.2.2. Maps of Development in 2011, Development in 2021 and Development Change

```{r, fig.height= 6, fig.width= 11}
tmap_arrange(
tm_shape(aggregatedRasters) +
  tm_fill(col = "developed2011", palette = palette2, n=2, style = "cat",
          title = "", labels = c("Undeveloped", "Developed")) +
  tm_layout(frame = F,legend.position = c("left", "top"),title = "Development 2011"),
tm_shape(aggregatedRasters) +
  tm_fill(col = "developed2021", palette = palette2, n=2, style = "cat",
          title = "", labels = c("Undeveloped", "Developed")) +
  tm_layout(frame = F,legend.position = c("left", "top"),title = "Development 2021"),
tm_shape(aggregatedRasters) +
  tm_fill(col = "development_change2", palette = palette2, n=2, style = "cat",
          title = "", labels = c("No Development Change", "Developed")) +
    tm_layout(frame = F,legend.position = c("left", "top"),title = "Development Change",
              legend.width = 1), 
  ncol = 3)

```

#### Fig 2.2.3. Frequency of Development Change in Cells from 2011 to 2021 by Majority Water

```{r Creating the aggregated raster, fig.height= 6, fig.width= 11}
aggregatedRasters %>% 
  st_drop_geometry() %>% 
  group_by(maj_water,developed2011,developed2021) %>% 
  tally() %>% 
  head() %>%
  kable() %>% kable_styling(full_width = F)
```

All but one of the majority water cells did not develop in this period
so these cells can safely be excluded from the model, to give better
accuracy in the rest of the study area.

## 2.3. Spatial Accessibility

Sprawl in Texas is driven by accessibility by car so spatial
accessibility is modeled on the distance to the nearest highway.

```{r Highway Data load}
if(Sys.getenv("USERNAME") == "adgob") {
  MSAHighways <- st_read("Data/TxDOT_Roadways.shp", quiet = TRUE)
}  else {
    #put your directory paths here !
   MSAHighways <- st_read("~/Desktop/modeling/HW5/TxDOT_Roadways_1642518016996364346/TxDOT_Roadways.shp")
}


MSAHighways <- MSAHighways  %>% 
  filter(RTE_PRFX %in% c("IH", 
                         "SH", 
                         "SA",
                         "SL",
                         "UA",
                         "US",
                         "TL"
                         )) %>% 
  st_transform(st_crs(pop_2021)) %>%  
  st_zm() %>% 
  .[pop_2021, , op=st_intersects]
```

```{r Highway Data to Fishnet, fig.width= 11}
emptyRaster <- dev_2021_4000
emptyRaster[] <- NA

highway_raster <- 
  as(MSAHighways,'Spatial') %>%
  rasterize(.,emptyRaster)

highway_raster_distance <- distance(highway_raster)
names(highway_raster_distance) <- "distance_highways"

highwayPoints <-
  rasterToPoints(highway_raster_distance) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(Austin_fishnet))

highwayPoints_fishnet <- 
  aggregate(highwayPoints, Austin_fishnet, mean) %>%
  mutate(distance_highways = ifelse(is.na(distance_highways),0,distance_highways))

# highwayPoints_fishnet5 <- cbind(highwayPoints_fishnet,c(highwayPoints_fishnet4)) 

tm_shape(highwayPoints_fishnet) +
  tm_fill(col = "distance_highways", palette = palette5, n = 5, style = "quantile",
          title = "Distance to\nNearest Highway\ntile /ft") +
    tm_layout(frame = F,legend.outside = T, legend.outside.position = c("right"),
              main.title = "Distance to Nearest Highway, 2011")
```

## 2.4. Development Lag

Development lag is also calculated as the mean of the distance to the
two nearest "developed" cells.

```{r Development Lag Calc, fig.width= 11}
nn_function <- function(measureFrom,measureTo,k) {
  #convert the sf layers to matrices
  measureFrom_Matrix <-
    as.matrix(measureFrom)
  measureTo_Matrix <-
    as.matrix(measureTo)
  nn <-   
    get.knnx(measureTo, measureFrom, k)$nn.dist
  output <-
    as.data.frame(nn) %>%
    rownames_to_column(var = "thisPoint") %>%
    gather(points, point_distance, V1:ncol(.)) %>%
    arrange(as.numeric(thisPoint)) %>%
    group_by(thisPoint) %>%
    summarize(pointDistance = mean(point_distance)) %>%
    arrange(as.numeric(thisPoint)) %>% 
    dplyr::select(-thisPoint) %>%
    pull()
  
  return(output)  
}

Austin_fishnet$lagDevelopment <-
    nn_function(xyC(Austin_fishnet),
                xyC(filter(aggregatedRasters,dev>0.3)), 
                2) 

Austin_fishnet <- Austin_fishnet %>% 
  mutate(ID = row_number())

tm_shape(Austin_fishnet) +
    tm_fill(col = "lagDevelopment", palette = palette5, n = 5, style = "fisher", 
          title = "Mean Distance\nto 2 Nearest\nDeveloped Tiles\n/ft") +
    tm_layout(frame = F,legend.outside = T, legend.outside.position = c("right"),
              main.title = "Spatial Lag of Development, 2011")
```

```{r combining the data}

#creating a dataset including water
dat_w <- 
  cbind(
    Austin_fishnet,
    aggregatedRasters, 
    st_drop_geometry(highwayPoints_fishnet), 
    st_drop_geometry(pop_fishnet)) %>%
    st_join(studyAreaCounties, join = st_intersects, largest = TRUE)

dat_w$NAME <- factor(dat_w$NAME) # making name column a factor instead of character

# cutting down out dataset to just areas that are not majority water
dat <- dat_w %>% 
  filter(maj_water == FALSE)
```

# 3. Exploratory Analysis

To build our model, we needed to test whether a factor was statistically
significant to some degree of change in development. By mapping
development in 2011 to 2021 and our factors of interest, we determined
whether a factor was significantly associated with a certain change in
development. For example, areas that experienced population change,
especially in 2021, tended to result in more new development, making
population change a notable indicator. Additionally, we tracked what
kinds of land uses were being developed between 2011 and 2021.

The following bar plots illustrate whether there is a significant
statistical difference between areas that did or did not change based on
a certain variable. For example, take the "lagDevelopment" variable
which asks, based on an area's proximity to existing development, how
many areas experienced new development or no change? The bar plot shows
that based on the variable, distance to existing development did not
result in lots of new development. However, this could be because areas
may already be highly developed.

#### Fig 3.1. Finding Statistically Significant Factors

```{r Graphing Development, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(distance_highways, lagDevelopment, development_change2) %>%
  mutate(development_change2 = factor(development_change2, levels = c(0, 1))) %>%
  gather(Variable, Value, -development_change2, -geometry) %>%
  ggplot(., aes(development_change2, Value, fill = development_change2)) + 
  geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
  facet_wrap(~Variable) +
  scale_fill_manual(values = palette2,
                    labels = c("No Change", "New Development"),
                    name = "") +
  labs(title = "New Development as a Function of the Continuous Variables") +
  plotTheme

```

```{r Graphing pop, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(pop_2011,pop_2021,pop_Change,development_change2) %>%
  mutate(development_change2 = factor(development_change2, levels = c(0, 1))) %>%
  gather(Variable, Value, -development_change2, -geometry) %>%
  ggplot(., aes(development_change2, Value, fill = development_change2)) + 
  geom_bar(position = "dodge", stat = "summary", fun.y = "mean") +
  facet_wrap(~Variable) +
  scale_fill_manual(values = palette2,
                    labels = c("No Change", "New Development"),
                    name = "") +
  labs(title = "New Development as a Function of the Continuous Variables") +
  plotTheme
```

#### Fig 3.2. Land Use Conversion Rates

The table below illustrates how much of a certain land use was
developed. For instance, about 0.49% of regional forests were developed
between 2011 to 2021.

```{r, warning = FALSE, message = FALSE}
dat %>%
  dplyr::select(development_change2:oUndev, dev, forest, water, wetland, farm) %>%
  gather(aggregatedRasters, Value, -development_change2, -geometry) %>%
   st_set_geometry(NULL) %>%
     group_by(development_change2, aggregatedRasters) %>%
     summarize(n = sum(as.numeric(Value))) %>%
     ungroup() %>%
    mutate(Conversion_Rate = paste0(round(100 * n/sum(n), 2), "%")) %>%
    filter(development_change2 == 1) %>%
  dplyr::select(aggregatedRasters, Conversion_Rate) %>%
  kable() %>% kable_styling(full_width = F)
```

# 4. Modeling

## 4.1. Building a Model

Attempting to project 2021 development based on 2011 data, we tested
various combinations of our factors and validated our models on actual
2021 development data.

```{r segregating data, warning = FALSE, message = FALSE, results='hide'}
set.seed(3456)
trainIndex <- 
  createDataPartition(dat$dev, p = .50,
                                  list = FALSE,
                                  times = 1)
datTrain <- dat[ trainIndex,]
datTest  <- dat[-trainIndex,]

nrow(dat)
```

```{r Running Models, warning = FALSE, message = FALSE, collapse=FALSE}
Model1 <- glm(development_change2 ~ wetland + forest  + farm + oUndev, 
              family="binomial"(link="logit"), data = datTrain)

Model2 <- glm(development_change2 ~ wetland + forest  + farm + oUndev + lagDevelopment, 
              family="binomial"(link="logit"), data = datTrain)

Model3 <- glm(development_change2 ~ wetland + forest  + farm + oUndev + lagDevelopment + pop_2011,
              family="binomial"(link="logit"), data = datTrain)
              
Model4 <- glm(development_change2 ~ wetland + forest  + farm + oUndev + lagDevelopment + pop_2011 + pop_2021,
              family="binomial"(link="logit"), data = datTrain)

Model5 <- glm(development_change2 ~ wetland + forest  + farm + oUndev + lagDevelopment + pop_Change,
              family="binomial"(link="logit"), data = datTrain) 
            
Model6 <- glm(development_change2 ~  wetland + forest  + farm + oUndev + lagDevelopment + pop_Change + distance_highways,
              family="binomial"(link="logit"), data = datTrain) 
```

#### Fig 4.1.1. McFadden R-Squared by Model

```{r Making model list, warning = FALSE, message = FALSE}
modelList <- paste0("Model", 1:6)
map_dfc(modelList, function(x)pR2(get(x)))[4,] %>%
  setNames(paste0("Model",1:6)) %>%
  gather(Model,McFadden) %>%
  ggplot(aes(Model,McFadden)) +
    geom_bar(stat="identity") +
    labs(title= "McFadden R-Squared by Model") +
    plotTheme


```

We chose Model 6 which resulted in the most accurate predictions and
included all of our factors of interest. Having validated our model with
recorded 2021 development data, we predicted 2031 development demand by
county.

The histogram illustrates the distribution of developed or no change
predictions. In order to really verify our model, we need to test the
model against a smaller development classification threshold.

#### Fig 4.1.2. Model 6 Test Set: Histogram of Predicted Probabilities

```{r Testing Models, warning = FALSE, message = FALSE}
testSetProbs <- 
  data.frame(class = datTest$development_change2,
             probs = predict(Model6, datTest, type="response")) 

mod_testSetProbs <- testSetProbs %>%
  dplyr::select(class,probs) %>%
  mutate(class = factor(class, levels = c(0, 1))) 
  
ggplot(mod_testSetProbs, aes(probs)) +
  geom_density(aes(fill=class), alpha=0.5) +
  scale_fill_manual(values = palette2,
                    labels=c("No Change","New Development")) +
  labs(title = "Histogram of test set predicted probabilities",
       x="Predicted Probabilities",y="Density") +
  plotTheme
```

#### Fig 4.1.3. Summary of Model 6

```{r}
summary(Model6)
```

## 4.2. Accuracy

#### Fig. 4.2.1 Sensitivity, Specificity and Accuracy of Model

```{r Accuracy 1, warning = FALSE, message = FALSE}
options(yardstick.event_first = FALSE)

testSetProbs <- 
  mod_testSetProbs %>% 
  mutate(predClass_05 = as.factor(ifelse(testSetProbs$probs >= 0.05 ,1,0)),
         predClass_17 = as.factor(ifelse(testSetProbs$probs >= 0.17 ,1,0))) 

testSetProbs %>% 
  dplyr::select(-probs) %>%
  gather(Variable, Value, -class) %>%
  group_by(Variable) %>%
  summarize(Sensitivity = round(yardstick::sens_vec(class,factor(Value)),2),
            Specificity = round(yardstick::spec_vec(class,factor(Value)),2),
            Accuracy = round(yardstick::accuracy_vec(class,factor(Value)),2)) %>% 
  kable() %>%
  kable_styling(full_width = F) 
```

#### Fig. 4.2.2 Actual vs. Predicted Development 2011 - 2021

```{r Accuracy 2, warning = FALSE, message = FALSE, fig.height = 6, fig.width= 8}
dat <-         
  dat %>%
    mutate(probs = predict(Model6, dat, type="response") ,
           Threshold_5_Pct = as.factor(ifelse(probs >= 0.05 ,1,0)),
           Threshold_17_Pct =  as.factor(ifelse(probs >= 0.17 ,1,0)))

tmap_arrange(
  tm_shape(dat) +
  tm_fill(col = "development_change2", palette = palette2, n = 2, style = "cat",
              legend.show = FALSE) +
    tm_layout(frame = F,title = "Actual Development 2011 - 2021"),
  tm_shape(dat) +
    tm_fill(col = "Threshold_5_Pct", palette = palette2, n = 2, style = "cat",
              legend.is.portrait = T,legend.position = "bottom", 
  labels=c("No Change","New Development"),
  title = "") +
    tm_layout(frame = F,title = "Pred. Development 5% Threshold",legend.width = 1),
  tm_shape(dat) +
    tm_fill(col = "Threshold_17_Pct", palette = palette2, n = 2, style = "cat",
              legend.show = FALSE) +
    tm_layout(frame = F,title = "Pred. Development 5% Threshold"),
  ncol = 3)
```

#### Fig. 4.2.3 Confusion Matrix

The confusion metrics measure a model's sensitivity, specificity, and
overall accuracy. Sensitivity refers to our model's true positive
predictions, that is, when change to development is predicted correctly.
Specificity refers to our model's false negatives, that is, when change
to development is predicted incorrectly. In these maps, two development
classification thresholds are implemented: 5 percent and 17 percent. In
both our 5 percent and 17 percent thresholds, our model tends to
correctly predict a high number of areas changed to "developed."
However, while our 5 percent threshold predicts both a high number of
"developed" areas and under-predicts the number of "no change" areas,
the 17 percent threshold is overall more accurate, because our data's
"no change" areas far outnumber areas where change was actually
observed. Ultimately, the 17 percent threshold offers a more accurate
modeling of Greater Austin, which tends to already be highly developed.

```{r Accuracy 3, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 8 }
ConfusionMatrix.metrics <-
  dat %>%
    mutate(probs = predict(Model6, dat, type="response") ,
           Threshold_5_Pct = as.factor(ifelse(probs >= 0.05 ,1,0)),
           Threshold_17_Pct =  as.factor(ifelse(probs >= 0.17 ,1,0))) %>%
    mutate(TrueP_05 = ifelse(development_change2  == 1 & Threshold_5_Pct == 1, 1,0),
           TrueN_05 = ifelse(development_change2  == 0 & Threshold_5_Pct == 0, 1,0),
           TrueP_17 = ifelse(development_change2  == 1 & Threshold_17_Pct == 1, 1,0),
           TrueN_17 = ifelse(development_change2  == 0 & Threshold_17_Pct == 0, 1,0)) %>%
    dplyr::select(., starts_with("True")) %>%
    gather(Variable, Value, -geometry) %>%
    st_cast("POLYGON") 

ggplot(data=ConfusionMatrix.metrics) +
  geom_point(aes(x=xyC(ConfusionMatrix.metrics)[,1], 
                 y=xyC(ConfusionMatrix.metrics)[,2], colour = as.factor(Value))) +
  facet_wrap(~Variable) +
  scale_colour_manual(values = palette2, labels=c("Incorrect","Correct"),
                       name="") +
  labs(title="Development Predictions - Low & High Threshold") + mapTheme
```

## 4.3. Generalizability

#### Fig. 4.3.1. Generalizability Metrics

```{r Generalizability 3, warning = FALSE, message = FALSE}
spatialCV <- function(dataFrame, uniqueID, dependentVariable, modelName) {

#initialize a data frame 
endList <- list()

#create a list that is all the spatial group unqiue ids in the data frame (ie counties)    
  uniqueID_List <- unique(dataFrame[[uniqueID]])  
  x <- 1
  y <- length(uniqueID_List)
  
#create a counter and while it is less than the number of counties...  
  while(x <= y) 
  {
#call a current county    
    currentUniqueID <- uniqueID_List[x]
#create a training set comprised of units not in that county and a test set of units
#that are that county
    training <- dataFrame[ which(dataFrame[[uniqueID]] != uniqueID_List[x]),]
    testing <- dataFrame[ which(dataFrame[[uniqueID]] == uniqueID_List[x]),]
#create seperate xy vectors
    trainingX <- training[ , -which(names(training) %in% c(dependentVariable))]
    testingX <- testing[ , -which(names(testing) %in% c(dependentVariable))]
    
    trainY <- training[[dependentVariable]]
    testY <- testing[[dependentVariable]]
#Calculate predictions on the test county as part of a data frame including the observed
#outcome and the unique county ID    
   thisPrediction <- 
     data.frame(class = testY,
                probs = predict(modelName, testingX, type="response"),
                county = currentUniqueID) 

#Row bind the predictions to a data farme
   endList <- rbind(endList, thisPrediction)
#iterate counter    
    x <- x + 1 
  } 
#return the final list of counties and associated predictions  
  return (as.data.frame(endList))
}

spatialCV_counties <-
  spatialCV(dat,"NAME","development_change2", Model6) %>%
  mutate(predClass = as.factor(ifelse(probs >= 0.17 ,1,0))) 
spatialCV_counties$class <- as.factor(spatialCV_counties$class)
spatialCV_counties$probs <- as.factor(spatialCV_counties$probs)

spatialCV_metrics <-
  spatialCV_counties %>% 
    group_by(county) %>% 
    summarize(Observed_Change = sum(as.numeric(as.factor(class))),
              Sensitivity = round(yardstick::sens_vec(class,predClass),2),
              Specificity = round(yardstick::spec_vec(class,predClass),2),
              Accuracy = round(yardstick::accuracy_vec(class,predClass),2))

spatialCV_metrics %>%
  kable() %>%
  kable_styling(full_width = F)

```

# 5. Predicting Development Demand for 2031

## 5.1. Predicting Development Demand

Population projection estimates were acquired from the Texas Demographic
Center and distributed to the census tracts with a step-down growth
share method.

#### Fig 5.1.1. Population Change by County: 2021 - 2031

```{r Predicting 1, warning = FALSE, message = FALSE}
# editing pop_2021 table
countyPopulation_2031 <- 
  data.frame(
   NAME = 
     c("Hays", "Travis", "Williamson","Bastrop","Caldwell"),
   county_projection_2031 = 
     c(369690,1599770,838036,123564,54523)) 

pop_2031 <- countyPopulation_2031 %>%
   left_join(
     pop_2021 %>% 
       mutate(NAME = word(NAME,4, sep = " "))%>%
       st_set_geometry(NULL) %>%
       group_by(NAME) %>%
       summarize(county_pop_2021 = sum(pop_2021))) %>%
   left_join(
     pop_2011 %>% 
       mutate(NAME = word(NAME,4, sep = " "))%>%
       st_set_geometry(NULL) %>%
       group_by(NAME) %>%
       summarize(county_pop_2011 = sum(pop_2011)))

pop_2031 %>%
  gather(Variable,Value, -NAME) %>%
  ggplot(aes(reorder(NAME,-Value),Value)) +
  geom_bar(aes(fill=Variable), stat = "identity", position = "dodge") +
  scale_fill_manual(values = palette4,
                    labels=c("2011","2021","2031"),
                    name="Population") +
  labs(x="County", y="Population") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  plotTheme

```

The map below shows development demand for the region, closely following
the existing highway network.

#### Fig 5.1.2. Development Demand in 2031: Predicted Probabilities

```{r Creaing infill map, warning = FALSE, message = FALSE, fig.width= 11}
dat_infill <-
  dat %>%
  #calculate population change
    left_join(pop_2031) %>%
    mutate(lagDevelopment = nn_function(xyC(.), xyC(filter(.,dev_2021 >0.3)),2),
         growth_share = (pop_2021-pop_2011)/(county_pop_2021-county_pop_2011),
         pop_2031.infill = (growth_share * (county_projection_2031 - county_pop_2021)) + pop_2021,
         pop_Change = round(pop_2031.infill - pop_2021)) %>%
  #predict for 2031
    mutate(predict_2031.infill = predict(Model6,. , type="response"))
# 
# dat_infill %>%
#   ggplot() +  
#   geom_point(aes(x=xyC(dat_infill)[,1], y=xyC(dat_infill)[,2], colour = factor(ntile(predict_2031.infill,5)))) +
#   scale_colour_manual(values = palette5,
#                     labels=substr(quintileBreaks(dat_infill,"predict_2031.infill"),1,4),
#                     name="Quintile\nBreaks") +
#    geom_sf(data=studyAreaCounties, fill=NA, colour="black", size=1) +
#   labs(title= "Development Demand in 2031: Predicted Probabilities") +
#   mapTheme 

tm_shape(dat_infill %>% 
           filter(developed2021 == 0)) +
  tm_fill(col = "predict_2031.infill", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Fixed\nBreaks", 
          legend.format = list(fun = legend_format)) +
  tm_shape(dat_infill %>% 
           filter(developed2021 == 1)) +
  tm_fill(col = "grey")+
  tm_shape(studyAreaCounties) +
  tm_borders(col = "black", lwd = 1) +
    tm_layout(frame = F,legend.outside = T, legend.outside.position = "right")

```

## 5.2. Predicting Using 2021 Land Cover Data

We can improve this prediction using updated land cover data from 2021,
replacing the 2011 land cover data we had been using.

```{r Creating the 2021 Rasterlist}
Raster_list2021 <- c()
Raster_names21 <- c()
for (x in 1:length(ClassMatrices)){ 
  # Reclassify land cover to the desired land cover type
  data <- reclassify(lc_austin_21, ClassMatrices[[x]])
  # Aggregate to get fraction of cell with that land type
  data <- aggregate(data, fact = 20, FUN = mean)
  # Name the data in the raster x_2021
  names(data) <- ClassNames[[x]]
  # Adds the raster to the raster list with the name x_2011_4000
  Raster_list2021 <- c(Raster_list2021,
                assign(ClassNames[[x]],data))
  # Adds the raster layer names to a list for running future code
  Raster_names21 <-  c(Raster_names21,
                     ClassNames[[x]])
}

dat2 <-
  aggregateRaster(Raster_list2021, 
                  dat_w)%>%
  dplyr::select((Raster_names)[1:6]) %>% 
  cbind(dat_w %>% 
          st_drop_geometry() %>% 
          mutate(modelpred21 = predict(Model6, dat_w, type="response")) %>% 
      rename(dev11 = dev,
             forest11 = forest,
             farm11 = farm,
             oUndev11 = oUndev,
             water11 = water,
             wetland11 = wetland,
             maj_water11 = maj_water,
             lagDevelopment11 = lagDevelopment,
             pop_Change11 = pop_Change,
             distance_highways = distance_highways)) %>% 
  mutate(maj_water = water > 0.5)

dat2 <-
  dat2 %>%
  left_join(pop_2031) %>% 
  mutate(lagDevelopment = nn_function(xyC(.), xyC(filter(.,dev > 0.3)),2),
         growth_share = (pop_2021-pop_2011)/(county_pop_2021-county_pop_2011),
         pop_2031.infill = (growth_share * (county_projection_2031 - county_pop_2021)) + pop_2021,
         pop_Change = round(pop_2031.infill - pop_2021)) 
```

#### Fig 5.2.1. Data Set 2 Full Model Characteristic Maps, 2021

```{r Tmap 2021, fig.height = 19, fig.width= 11}
tmap_arrange(
  tm_shape(dat2) +
  tm_fill(col = "dev", palette = palette5, n = 5, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Percent Developed Land Cover 2021"),
  tm_shape(dat2) +
    tm_fill(col = "forest", palette = palette5, n = 5, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Percent Forest Land Cover 2021"),
  tm_shape(dat2) +
    tm_fill(col = "farm", palette = palette4, n = 4, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Percent Farm Land Cover 2021"), 
  tm_shape(dat2) +
    tm_fill(col = "wetland", palette = palette4, n = 3, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Percent Wetland Land Cover 2021"),
  tm_shape(dat2) +
    tm_fill(col = "oUndev", palette = palette5, n = 5, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Percent Other Undeveloped Land Cover 2021"), 
  tm_shape(dat2) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "fisher",
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Population Change 2021 - 2031"), 
  tm_shape(dat2) +
    tm_fill(col = "lagDevelopment", palette = palette5, n = 5, style = "fisher", 
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Spatial Lag of Development 2021"),
  tm_shape(dat2) +
    tm_fill(col = "distance_highways", palette = palette5, n = 5, style = "fisher", 
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Distance to Highways 2021"),
  tm_shape(dat2) +
    tm_fill(col = "water", palette = palette4, n = 3, style = "fisher", 
          legend.format = list(fun = legend_formatper),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Percent Water Land Cover 2021"),
  tm_shape(dat2) +
    tm_fill(col = "maj_water", palette = palette2, n = 2, style = "cat") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              title = "Cell is Majority Water Feature 2021"), 
  ncol = 2)
```

#### Fig 5.2.2. Predicted Development Growth

```{r, fig.height= 8, fig.width= 11}
dat2 <-
  dat2%>%
    mutate(Development_Demand = predict(Model6, dat2, type="response"),
           Pred_5_Pct = as.factor(ifelse(Development_Demand >= 0.05 ,1,0)),
           Pred_17_Pct =  as.factor(ifelse(Development_Demand >= 0.17 ,1,0)))

tmap_arrange(
tm_shape(dat2) +
  tm_fill(col = "Development_Demand", palette = palette5, n = 5, style = "fisher",
              legend.is.portrait = T, legend.format = list(fun = legend_format),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom"),
              legend.width = 1,
             main.title = "Predicted Growth with Updated Land Cover Data, 2031")
,
tm_shape(dat2) +
  tm_fill(col = "Pred_17_Pct", palette = palette2, n = 2, style = "cat",
              legend.is.portrait = T, labels = c("No Development", "New Development"),
          title = "") +
    tm_layout(frame = F,legend.position = c("right", "bottom",
              legend.width = 1),
             main.title = "Predicted Growth with a Model Threshold of 17%, 2031")
,ncol = 2)
```

## 5.3. Summarizing Change by County

The development demand metrics provides supply and demand side analytics
for all counties. Based on the table, Williamson County will experience
the most mean development demand as well as a considerable population
change.

```{r pop 2031, warning = FALSE, message = FALSE, fig.height = 6, fig.width= 6}
dat2 <-
  dat2 %>%
   mutate(sensitive_lost = ifelse(forest11 > 0.3 & forest < 0.3 |
                                    wetland11 > 0.3 & wetland < 0.3,1,0))

countypop_2031csm <- 
  data.frame(
   NAME = 
     c("Hays", "Travis", "Williamson","Bastrop","Caldwell"),
   county_projection_2031 = 
     c(369690,1599770,838036,123564,54523)) 
# editing pop_2021 table for csm
pop_2021csm <- pop_2021
pop_2021csm$NAME <- word(pop_2021csm$NAME,4, sep = " ")

pop_2031csm <- countypop_2031csm %>%
   left_join(
     pop_2021csm %>%
       st_set_geometry(NULL) %>%
       group_by(NAME) %>%
       summarize(county_pop_2021 = sum(pop_2021)))
# now we can summarize by county 
county_specific_metrics <- 
  dat2 %>%
  #predict development demand from our model
  mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
  #get a count count of grid cells by county which we can use to calculate rates below 
  left_join(st_set_geometry(dat, NULL) %>% group_by(NAME) %>% summarize(count = n())) %>%
  #calculate summary statistics by county
  group_by(NAME) %>%
  summarize(Total_Farmland = sum(farm) / max(count),
            Total_Forest = sum(forest) / max(count),
            Total_Wetlands = sum(wetland) / max(count),
            Total_Undeveloped = sum(oUndev) / max(count),
            Sensitive_Land_Lost = sum(sensitive_lost) / max(count),
           #  Sensitive_Regions = sum(sensitiveRegions) / max(count), # if there comes a point where this can be included 
            Mean_Development_Demand = mean(Development_Demand)) %>%
# get population data by county
left_join(pop_2031csm %>% 
            mutate(Population_Change = county_projection_2031 - county_pop_2021,
            Population_Change_Rate = Population_Change / county_projection_2031) %>%
            dplyr::select(NAME,Population_Change_Rate))

county_specific_metrics %>%
  gather(Variable, Value, -NAME, -geometry) %>%
  mutate(Variable = factor(Variable, levels=c("Population_Change_Rate","Mean_Development_Demand",
                                              "Total_Farmland","Total_Undeveloped","Total_Forest",
                                              "Total_Wetlands","Sensitive_Land_Lost", # "Sensitive_Regions", (include sensitive regions at another point)
                                              ordered = TRUE))) %>%
  mutate(Planning_Designation = case_when(
    Variable == "Population_Change_Rate" | Variable == "Mean_Development_Demand" ~ "Demand-Side",
    Variable == "Total_Farmland" | Variable == "Total_Undeveloped"               ~ "Suitable",
    TRUE                                                                         ~ "Not Suitable")) %>%
  ggplot(aes(x=Variable, y=Value, fill=Planning_Designation)) +
    geom_bar(stat="identity", position=position_dodge(), colour="black") +
    facet_wrap(~NAME, ncol=5) +
    coord_flip() +
    scale_y_continuous(breaks = seq(.25, 1, by = .25)) +
    geom_vline(xintercept = 2.5) + geom_vline(xintercept = 4.5) +
    scale_fill_manual(values=c("black","red","darkgreen")) +
    labs(title= "County Specific Allocation Metrics", subtitle= "As rates", x="Indicator", y="Rate", fill = "Planning Designation") +
    plotTheme + theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position="bottom")

```

Note. The development demand metrics provides supply and demand side
analytics for all counties. Based on the table, Williamson County will
experience the most mean development demand as well as a considerable
population change (see Figure 10) .

# 6. Scenario 1: BAU, Greater Austin's Built and Natural Environment at Present.

Based on our 2031 Development Demand map and our county-specific
analytics, we observed Williamson County as the county that will
experience the highest development demand alongside considerable
population increase. We determined where development would best be
allocated by identifying areas of high development demand and population
increase while prohibiting development on sensitive environmental land
like wetlands and forest.

The maps below show each County: the map on the left depicts where
development is most likely to occur based on our model's prediction, and
the map on the right depicts population change in each county. Each map
is overlayed with existing developed areas in grey and sensitive
environmental regions in red. Development can not take place in either
of these locations so the most suitable and desirable areas are the dark
blue map areas without any overlays on them.

```{r Fragmentation, fig.height= 8, fig.width= 11}
senseM <- 
  matrix(c(
    0,.5,NA,
    .5,Inf,1),
  ncol=3, byrow=T)

sensitiveRegions <- 
  reclassify(wetland + forest, senseM) %>% 
  raster::clump() %>%
  rasterToPolygons() %>%
  st_as_sf() %>%
  group_by(clumps) %>% 
  summarize() %>%
    mutate(Acres = as.numeric(st_area(.) * 0.0000229568)) %>%
    filter(Acres > 3954)  %>%
  dplyr::select() %>%
  raster::rasterize(.,emptyRaster) 
sensitiveRegions[sensitiveRegions > 0] <- 1  
names(sensitiveRegions) <- "sensitiveRegions"

dat2 <-
  aggregateRaster(c(sensitiveRegions), dat2) %>%
  dplyr::select(sensitiveRegions) %>%
  st_set_geometry(NULL) %>%
  bind_cols(.,dat2) %>%
  st_sf() 
```

#### Fig 6.1. Development Allocation for Austin MSA

```{r Tmap 3, fig.height = 8, fig.width= 11}
dat2_landUse <- dat2 %>% 
  filter(sensitiveRegions == 1 | developed2021 == 1 )%>% 
  mutate(Land_Use = if_else(developed2021 == 1,"Developed","Not Suitable")) %>%
  dplyr::select(Land_Use, NAME) 

tmap_arrange(
  tm_shape(dat2) +
      tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Development\nDemand", 
          legend.format = list(fun = legend_format)) +
    tm_shape(dat2_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,studyAreaCounties))  +
    tm_lines(col = "black")  +
    tm_layout(frame = F,main.title = "Development Potential, 2031",
              legend.position = c("right", "bottom"))
  ,
  tm_shape(dat2) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
              legend.is.portrait = TRUE,
          title = "Population\nChange") +
    tm_shape(dat2_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,studyAreaCounties)) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,main.title = "Projected Population, 2031",
              legend.position = c("right","bottom")),
ncol = 2)
```

#### Fig 6.2. Williamson County

```{r Williamson, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
williamson <-
  dat2%>%
    filter(NAME == "Williamson") 

williamson_landUse <- dat2_landUse %>% 
    filter(NAME == "Williamson") 
  
tmap_arrange(
  tm_shape(williamson) +
      tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Development\nDemand", 
          legend.format = list(fun = legend_format)) +
    tm_shape(williamson_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Williamson"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Development Potential, 2031: Williamson",
              legend.position = c("right", "bottom"))
  ,
  tm_shape(williamson) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
              legend.is.portrait = TRUE,
          title = "Population\nChange") +
    tm_shape(williamson_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.5,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Williamson"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Projected Population, 2031: Williamson",
              legend.position = c("right","bottom")),
ncol = 2)
```

#### Fig 6.3. Travis County

```{r Travis, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
travis <-
  dat2 %>%
    mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
    filter(NAME == "Travis") 

travis_landUse <- dat2_landUse %>% 
    filter(NAME == "Travis") 


tmap_arrange(
  tm_shape(travis) +
      tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Development\nDemand", 
          legend.format = list(fun = legend_format)) +
    tm_shape(travis_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Travis"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Development Potential, 2031: Travis",
              legend.position = c("right", "bottom"))
  ,
  tm_shape(travis) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
              legend.is.portrait = TRUE,
          title = "Population\nChange") +
    tm_shape(travis_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.5,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Travis"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Projected Population, 2031: Travis",
              legend.position = c("right","bottom")),
ncol = 2)
```

#### Fig 6.4. Hays County

```{r Hays, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
hays <-
  dat2 %>%
    mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
    filter(NAME == "Hays") 

hays_landUse <- dat2_landUse %>% 
    filter(NAME == "Hays") 

tmap_arrange(
  tm_shape(hays) +
      tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Development\nDemand", 
          legend.format = list(fun = legend_format)) +
    tm_shape(hays_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Hays"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Development Potential, 2031: Hays",
              legend.position = c("right", "bottom"))
  ,
  tm_shape(hays) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
              legend.is.portrait = TRUE,
          title = "Population\nChange") +
     tm_shape(hays_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.5,
              legend.is.portrait = T) +
    tm_layout(frame = F,title = "Projected Population, 2031: Hays",
              legend.position = c("right","bottom")),
ncol = 2)
```

#### Fig 6.5. Caldwell County.

```{r Caldwell, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
caldwell <-
  dat2 %>%
    mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
    filter(NAME == "Caldwell") 

caldwell_landUse <- dat2_landUse %>% 
    filter(NAME == "Caldwell") 

tmap_arrange(
  tm_shape(caldwell) +
      tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Development\nDemand", 
          legend.format = list(fun = legend_format)) +
    tm_shape(caldwell_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Caldwell"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Development Potential, 2031: Caldwell",
              legend.position = c("right", "bottom"))
  ,
  tm_shape(caldwell) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
              legend.is.portrait = TRUE,
          title = "Population\nChange") +
    tm_shape(caldwell_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.5,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Caldwell"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Projected Population, 2031: Caldwell",
              legend.position = c("right","bottom")),
ncol = 2)
```

#### Fig 6.6. Bastrop County.

```{r Bastrop, warning = FALSE, message = FALSE, fig.height= 8, fig.width= 11}
bastrop <-
  dat2 %>%
    mutate(Development_Demand = predict(Model6, dat2, type="response")) %>%
    filter(NAME == "Bastrop") 

bastrop_landUse <- dat2_landUse %>%
    filter(NAME == "Bastrop") 

tmap_arrange(
  tm_shape(bastrop) +
     tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Development\nDemand", 
          legend.format = list(fun = legend_format)) +
    tm_shape(bastrop_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.8,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Bastrop"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Development Potential, 2031: Bastrop",
              legend.position = c("right", "bottom"))
  ,
  tm_shape(bastrop) +
    tm_fill(col = "pop_Change", palette = palette5, n = 5, style = "quantile",
              legend.is.portrait = TRUE,
          title = "Population\nChange") +
    tm_shape(bastrop_landUse) +
    tm_fill(col = "Land_Use", palette = c("grey","red"), n = 2, style = "cat",
          title = "Land Use", alpha = 0.5,
              legend.is.portrait = T) +
    tm_shape(st_intersection(MSAHighways,filter(studyAreaCounties, NAME=="Bastrop"))) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Projected Population, 2031: Bastrop",
              legend.position = c("right","bottom")),
ncol = 2)
```

# 7. Scenario 2: Estimating the effect of new transportation

The second scenario operates on the development of two (fake) proposed
highways connecting areas southeast and southwest of the city to
downtown Austin. These new highways might act as new attracting factors
and may spur further development along these new corridors.

#### Fig 7.1. Map of the Proposed New Highways

```{r New Highway, warning = FALSE, message = FALSE}
MSAHighways2 <- st_read(dsn = here::here("Data/MSAHighways_new2.shp"), quiet = TRUE) %>%
  st_transform(st_crs(pop_2021))

highway_raster2 <-
  as(MSAHighways2,'Spatial') %>%
  rasterize(.,emptyRaster)

highway_raster_distance2 <- distance(highway_raster2)
names(highway_raster_distance2) <- "distance_highways2"

highwayPoints2 <-
  rasterToPoints(highway_raster_distance2) %>%
  as.data.frame() %>%
  st_as_sf(coords = c("x", "y"), crs = st_crs(Austin_fishnet))

highwayPoints_fishnet2 <-
  aggregate(highwayPoints2, Austin_fishnet, mean) %>%
  mutate(distance_highways2 = ifelse(is.na(distance_highways2),0,distance_highways2))

tm_shape(studyAreaCounties) +
    tm_fill(col = palette5[1]) +
tm_shape(st_intersection(MSAHighways2,studyAreaCounties)) +
    tm_lines(col = "red") +
  tm_shape(st_intersection(MSAHighways,studyAreaCounties)) +
    tm_lines(col = "black")
```

#### Fig 7.2. Map of Development Demand with Existing and New Highways

```{r Modeling with the old and new maps, fig.height= 8, fig.width= 11}
dat3 <- cbind(dat2 %>% 
                mutate(distance_highways_old = distance_highways),
              st_drop_geometry(highwayPoints_fishnet2)) %>% 
  mutate(distance_highways = distance_highways2)

dat3 <-
  dat3 %>%
    mutate(Growth_Predict = predict(Model6, dat3, type="response")) %>% 
  filter(!maj_water)


tmap_arrange(
tm_shape(dat2 %>% 
           filter(!maj_water)) +
     tm_fill(col = "Development_Demand", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Fixed\nThresholds", 
          legend.format = list(fun = legend_format)) +
  tm_shape(dat3 %>%
           filter(developed2021 == 1)) +
  tm_fill(col = "grey") +
    tm_shape(st_intersection(MSAHighways,studyAreaCounties)) +
    tm_lines(col = "black")  +
    tm_layout(frame = F,title = "Projected Urban Growth w/ Existing Highways",
              legend.position = c("right","bottom"))
,
tm_shape(dat3) +
     tm_fill(col = "Growth_Predict", 
          palette = palette5,  style = "fixed",
          breaks = c(0,0.05,0.17,1),
          title = "Fixed\nThresholds", 
          legend.format = list(fun = legend_format)) +
  tm_shape(dat3 %>%
           filter(developed2021 == 1)) +
  tm_fill(col = "grey")+
    tm_shape(st_intersection(MSAHighways2,studyAreaCounties)) +
    tm_lines(col = "red")  +
    tm_shape(st_intersection(MSAHighways,studyAreaCounties)) +
    tm_lines(col = "black") +
    tm_layout(frame = F,title = "Projected Urban Growth w/ New Highway",
              legend.position = c("right","bottom"))
,
ncol = 2)

dat3 %>%
  dplyr::select(developed2021, Development_Demand,Growth_Predict) %>%
   st_drop_geometry() %>%
  rename("Predicted Development with Existing Highways" = Development_Demand,
         "Predicted Development with New Highway" = Growth_Predict) %>%
  filter(developed2021 == 0) %>%
  dplyr::select(-developed2021) %>% 
  gather(Scenario, Value) %>%
  mutate(Develops = if_else(Value > 0.17, 1, 0)) %>% 
     group_by(Scenario) %>%
     summarize(Prediction = sum(as.numeric(Develops))) %>%
     ungroup() %>%
  kable() %>% kable_styling(full_width = F)
```

The model predicts 19 cells would be developed on top of
business-as-usual, as a result of the proposed highways. The model does
not account for how useful a highway for connecting useful amenities and
locations so the impact of a new highway would depend heavily on what it
is connecting. Careful planning is still needed to assess the potential
effects of major infrastructure projects like this, beyond what the
model predicts.

# 8. Works Cited

Buchele, M. (2023). A 'climate feedback loop': Why Austin is locked in
one of its hottest summers ever. KUTNews.
<https://www.kut.org/energy-environment/2023-08-14/a-climate-feedback-loop-why-Austin-is-locked-in-one-of-its-hottest-summers-ever>.
Accessed 28 April 2024.

City of Austin. (2023). City Closes Extreme Heat Resources for the
Summer [Press Release]. City of Austin.
<https://www.austintexas.gov/news/city-closes-extreme-heat-resources-summer#:~:text=Central%20Texas%20experienced%20its%20hottest,Heat%20Warning%20for%2038%20days>.
Accessed 29 April 2024.

City of Austin. (2024). New Census Data: Austin Metro Slips from Top
Spot, Remains One of the Nation's Fastest Growing Regions [Press
Release]. City of Austin.
<https://www.austintexas.gov/news/new-census-data-austin-metro-slips-top-spot-remains-one-nations-fastest-growing-regions>.
Accessed 28 April 2024.

Steif, K. (2019). Urban Growth Modeling, 2022. M. Fichman and J. Epstein
(Eds.).
